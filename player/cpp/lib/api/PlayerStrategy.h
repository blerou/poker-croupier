/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef PlayerStrategy_H
#define PlayerStrategy_H

#include <thrift/TDispatchProcessor.h>
#include "player_strategy_types.h"

namespace API {

class PlayerStrategyIf {
 public:
  virtual ~PlayerStrategyIf() {}
  virtual void name(std::string& _return) = 0;
  virtual int64_t bet_request(const int64_t pot, const  ::API::BetLimits& limits) = 0;
  virtual void competitor_status(const  ::API::Competitor& competitor) = 0;
  virtual void bet(const  ::API::Competitor& competitor, const  ::API::Bet& bet) = 0;
  virtual void hole_card(const  ::API::Card& card) = 0;
  virtual void community_card(const  ::API::Card& card) = 0;
  virtual void showdown(const  ::API::Competitor& competitor, const std::vector< ::API::Card> & cards, const  ::API::HandDescriptor& hand) = 0;
  virtual void winner(const  ::API::Competitor& competitor, const int64_t amount) = 0;
  virtual void shutdown() = 0;
};

class PlayerStrategyIfFactory {
 public:
  typedef PlayerStrategyIf Handler;

  virtual ~PlayerStrategyIfFactory() {}

  virtual PlayerStrategyIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(PlayerStrategyIf* /* handler */) = 0;
};

class PlayerStrategyIfSingletonFactory : virtual public PlayerStrategyIfFactory {
 public:
  PlayerStrategyIfSingletonFactory(const boost::shared_ptr<PlayerStrategyIf>& iface) : iface_(iface) {}
  virtual ~PlayerStrategyIfSingletonFactory() {}

  virtual PlayerStrategyIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(PlayerStrategyIf* /* handler */) {}

 protected:
  boost::shared_ptr<PlayerStrategyIf> iface_;
};

class PlayerStrategyNull : virtual public PlayerStrategyIf {
 public:
  virtual ~PlayerStrategyNull() {}
  void name(std::string& /* _return */) {
    return;
  }
  int64_t bet_request(const int64_t /* pot */, const  ::API::BetLimits& /* limits */) {
    int64_t _return = 0;
    return _return;
  }
  void competitor_status(const  ::API::Competitor& /* competitor */) {
    return;
  }
  void bet(const  ::API::Competitor& /* competitor */, const  ::API::Bet& /* bet */) {
    return;
  }
  void hole_card(const  ::API::Card& /* card */) {
    return;
  }
  void community_card(const  ::API::Card& /* card */) {
    return;
  }
  void showdown(const  ::API::Competitor& /* competitor */, const std::vector< ::API::Card> & /* cards */, const  ::API::HandDescriptor& /* hand */) {
    return;
  }
  void winner(const  ::API::Competitor& /* competitor */, const int64_t /* amount */) {
    return;
  }
  void shutdown() {
    return;
  }
};


class PlayerStrategy_name_args {
 public:

  PlayerStrategy_name_args() {
  }

  virtual ~PlayerStrategy_name_args() throw() {}


  bool operator == (const PlayerStrategy_name_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const PlayerStrategy_name_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_name_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_name_pargs {
 public:


  virtual ~PlayerStrategy_name_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _PlayerStrategy_name_result__isset {
  _PlayerStrategy_name_result__isset() : success(false) {}
  bool success;
} _PlayerStrategy_name_result__isset;

class PlayerStrategy_name_result {
 public:

  PlayerStrategy_name_result() : success() {
  }

  virtual ~PlayerStrategy_name_result() throw() {}

  std::string success;

  _PlayerStrategy_name_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const PlayerStrategy_name_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const PlayerStrategy_name_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_name_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _PlayerStrategy_name_presult__isset {
  _PlayerStrategy_name_presult__isset() : success(false) {}
  bool success;
} _PlayerStrategy_name_presult__isset;

class PlayerStrategy_name_presult {
 public:


  virtual ~PlayerStrategy_name_presult() throw() {}

  std::string* success;

  _PlayerStrategy_name_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _PlayerStrategy_bet_request_args__isset {
  _PlayerStrategy_bet_request_args__isset() : pot(false), limits(false) {}
  bool pot;
  bool limits;
} _PlayerStrategy_bet_request_args__isset;

class PlayerStrategy_bet_request_args {
 public:

  PlayerStrategy_bet_request_args() : pot(0) {
  }

  virtual ~PlayerStrategy_bet_request_args() throw() {}

  int64_t pot;
   ::API::BetLimits limits;

  _PlayerStrategy_bet_request_args__isset __isset;

  void __set_pot(const int64_t val) {
    pot = val;
  }

  void __set_limits(const  ::API::BetLimits& val) {
    limits = val;
  }

  bool operator == (const PlayerStrategy_bet_request_args & rhs) const
  {
    if (!(pot == rhs.pot))
      return false;
    if (!(limits == rhs.limits))
      return false;
    return true;
  }
  bool operator != (const PlayerStrategy_bet_request_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_bet_request_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_bet_request_pargs {
 public:


  virtual ~PlayerStrategy_bet_request_pargs() throw() {}

  const int64_t* pot;
  const  ::API::BetLimits* limits;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _PlayerStrategy_bet_request_result__isset {
  _PlayerStrategy_bet_request_result__isset() : success(false) {}
  bool success;
} _PlayerStrategy_bet_request_result__isset;

class PlayerStrategy_bet_request_result {
 public:

  PlayerStrategy_bet_request_result() : success(0) {
  }

  virtual ~PlayerStrategy_bet_request_result() throw() {}

  int64_t success;

  _PlayerStrategy_bet_request_result__isset __isset;

  void __set_success(const int64_t val) {
    success = val;
  }

  bool operator == (const PlayerStrategy_bet_request_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const PlayerStrategy_bet_request_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_bet_request_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _PlayerStrategy_bet_request_presult__isset {
  _PlayerStrategy_bet_request_presult__isset() : success(false) {}
  bool success;
} _PlayerStrategy_bet_request_presult__isset;

class PlayerStrategy_bet_request_presult {
 public:


  virtual ~PlayerStrategy_bet_request_presult() throw() {}

  int64_t* success;

  _PlayerStrategy_bet_request_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _PlayerStrategy_competitor_status_args__isset {
  _PlayerStrategy_competitor_status_args__isset() : competitor(false) {}
  bool competitor;
} _PlayerStrategy_competitor_status_args__isset;

class PlayerStrategy_competitor_status_args {
 public:

  PlayerStrategy_competitor_status_args() {
  }

  virtual ~PlayerStrategy_competitor_status_args() throw() {}

   ::API::Competitor competitor;

  _PlayerStrategy_competitor_status_args__isset __isset;

  void __set_competitor(const  ::API::Competitor& val) {
    competitor = val;
  }

  bool operator == (const PlayerStrategy_competitor_status_args & rhs) const
  {
    if (!(competitor == rhs.competitor))
      return false;
    return true;
  }
  bool operator != (const PlayerStrategy_competitor_status_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_competitor_status_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_competitor_status_pargs {
 public:


  virtual ~PlayerStrategy_competitor_status_pargs() throw() {}

  const  ::API::Competitor* competitor;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_competitor_status_result {
 public:

  PlayerStrategy_competitor_status_result() {
  }

  virtual ~PlayerStrategy_competitor_status_result() throw() {}


  bool operator == (const PlayerStrategy_competitor_status_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const PlayerStrategy_competitor_status_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_competitor_status_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_competitor_status_presult {
 public:


  virtual ~PlayerStrategy_competitor_status_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _PlayerStrategy_bet_args__isset {
  _PlayerStrategy_bet_args__isset() : competitor(false), bet(false) {}
  bool competitor;
  bool bet;
} _PlayerStrategy_bet_args__isset;

class PlayerStrategy_bet_args {
 public:

  PlayerStrategy_bet_args() {
  }

  virtual ~PlayerStrategy_bet_args() throw() {}

   ::API::Competitor competitor;
   ::API::Bet bet;

  _PlayerStrategy_bet_args__isset __isset;

  void __set_competitor(const  ::API::Competitor& val) {
    competitor = val;
  }

  void __set_bet(const  ::API::Bet& val) {
    bet = val;
  }

  bool operator == (const PlayerStrategy_bet_args & rhs) const
  {
    if (!(competitor == rhs.competitor))
      return false;
    if (!(bet == rhs.bet))
      return false;
    return true;
  }
  bool operator != (const PlayerStrategy_bet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_bet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_bet_pargs {
 public:


  virtual ~PlayerStrategy_bet_pargs() throw() {}

  const  ::API::Competitor* competitor;
  const  ::API::Bet* bet;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_bet_result {
 public:

  PlayerStrategy_bet_result() {
  }

  virtual ~PlayerStrategy_bet_result() throw() {}


  bool operator == (const PlayerStrategy_bet_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const PlayerStrategy_bet_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_bet_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_bet_presult {
 public:


  virtual ~PlayerStrategy_bet_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _PlayerStrategy_hole_card_args__isset {
  _PlayerStrategy_hole_card_args__isset() : card(false) {}
  bool card;
} _PlayerStrategy_hole_card_args__isset;

class PlayerStrategy_hole_card_args {
 public:

  PlayerStrategy_hole_card_args() {
  }

  virtual ~PlayerStrategy_hole_card_args() throw() {}

   ::API::Card card;

  _PlayerStrategy_hole_card_args__isset __isset;

  void __set_card(const  ::API::Card& val) {
    card = val;
  }

  bool operator == (const PlayerStrategy_hole_card_args & rhs) const
  {
    if (!(card == rhs.card))
      return false;
    return true;
  }
  bool operator != (const PlayerStrategy_hole_card_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_hole_card_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_hole_card_pargs {
 public:


  virtual ~PlayerStrategy_hole_card_pargs() throw() {}

  const  ::API::Card* card;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_hole_card_result {
 public:

  PlayerStrategy_hole_card_result() {
  }

  virtual ~PlayerStrategy_hole_card_result() throw() {}


  bool operator == (const PlayerStrategy_hole_card_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const PlayerStrategy_hole_card_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_hole_card_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_hole_card_presult {
 public:


  virtual ~PlayerStrategy_hole_card_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _PlayerStrategy_community_card_args__isset {
  _PlayerStrategy_community_card_args__isset() : card(false) {}
  bool card;
} _PlayerStrategy_community_card_args__isset;

class PlayerStrategy_community_card_args {
 public:

  PlayerStrategy_community_card_args() {
  }

  virtual ~PlayerStrategy_community_card_args() throw() {}

   ::API::Card card;

  _PlayerStrategy_community_card_args__isset __isset;

  void __set_card(const  ::API::Card& val) {
    card = val;
  }

  bool operator == (const PlayerStrategy_community_card_args & rhs) const
  {
    if (!(card == rhs.card))
      return false;
    return true;
  }
  bool operator != (const PlayerStrategy_community_card_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_community_card_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_community_card_pargs {
 public:


  virtual ~PlayerStrategy_community_card_pargs() throw() {}

  const  ::API::Card* card;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_community_card_result {
 public:

  PlayerStrategy_community_card_result() {
  }

  virtual ~PlayerStrategy_community_card_result() throw() {}


  bool operator == (const PlayerStrategy_community_card_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const PlayerStrategy_community_card_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_community_card_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_community_card_presult {
 public:


  virtual ~PlayerStrategy_community_card_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _PlayerStrategy_showdown_args__isset {
  _PlayerStrategy_showdown_args__isset() : competitor(false), cards(false), hand(false) {}
  bool competitor;
  bool cards;
  bool hand;
} _PlayerStrategy_showdown_args__isset;

class PlayerStrategy_showdown_args {
 public:

  PlayerStrategy_showdown_args() {
  }

  virtual ~PlayerStrategy_showdown_args() throw() {}

   ::API::Competitor competitor;
  std::vector< ::API::Card>  cards;
   ::API::HandDescriptor hand;

  _PlayerStrategy_showdown_args__isset __isset;

  void __set_competitor(const  ::API::Competitor& val) {
    competitor = val;
  }

  void __set_cards(const std::vector< ::API::Card> & val) {
    cards = val;
  }

  void __set_hand(const  ::API::HandDescriptor& val) {
    hand = val;
  }

  bool operator == (const PlayerStrategy_showdown_args & rhs) const
  {
    if (!(competitor == rhs.competitor))
      return false;
    if (!(cards == rhs.cards))
      return false;
    if (!(hand == rhs.hand))
      return false;
    return true;
  }
  bool operator != (const PlayerStrategy_showdown_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_showdown_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_showdown_pargs {
 public:


  virtual ~PlayerStrategy_showdown_pargs() throw() {}

  const  ::API::Competitor* competitor;
  const std::vector< ::API::Card> * cards;
  const  ::API::HandDescriptor* hand;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_showdown_result {
 public:

  PlayerStrategy_showdown_result() {
  }

  virtual ~PlayerStrategy_showdown_result() throw() {}


  bool operator == (const PlayerStrategy_showdown_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const PlayerStrategy_showdown_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_showdown_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_showdown_presult {
 public:


  virtual ~PlayerStrategy_showdown_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _PlayerStrategy_winner_args__isset {
  _PlayerStrategy_winner_args__isset() : competitor(false), amount(false) {}
  bool competitor;
  bool amount;
} _PlayerStrategy_winner_args__isset;

class PlayerStrategy_winner_args {
 public:

  PlayerStrategy_winner_args() : amount(0) {
  }

  virtual ~PlayerStrategy_winner_args() throw() {}

   ::API::Competitor competitor;
  int64_t amount;

  _PlayerStrategy_winner_args__isset __isset;

  void __set_competitor(const  ::API::Competitor& val) {
    competitor = val;
  }

  void __set_amount(const int64_t val) {
    amount = val;
  }

  bool operator == (const PlayerStrategy_winner_args & rhs) const
  {
    if (!(competitor == rhs.competitor))
      return false;
    if (!(amount == rhs.amount))
      return false;
    return true;
  }
  bool operator != (const PlayerStrategy_winner_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_winner_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_winner_pargs {
 public:


  virtual ~PlayerStrategy_winner_pargs() throw() {}

  const  ::API::Competitor* competitor;
  const int64_t* amount;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_winner_result {
 public:

  PlayerStrategy_winner_result() {
  }

  virtual ~PlayerStrategy_winner_result() throw() {}


  bool operator == (const PlayerStrategy_winner_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const PlayerStrategy_winner_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_winner_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_winner_presult {
 public:


  virtual ~PlayerStrategy_winner_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class PlayerStrategy_shutdown_args {
 public:

  PlayerStrategy_shutdown_args() {
  }

  virtual ~PlayerStrategy_shutdown_args() throw() {}


  bool operator == (const PlayerStrategy_shutdown_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const PlayerStrategy_shutdown_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStrategy_shutdown_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class PlayerStrategy_shutdown_pargs {
 public:


  virtual ~PlayerStrategy_shutdown_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class PlayerStrategyClient : virtual public PlayerStrategyIf {
 public:
  PlayerStrategyClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  PlayerStrategyClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void name(std::string& _return);
  void send_name();
  void recv_name(std::string& _return);
  int64_t bet_request(const int64_t pot, const  ::API::BetLimits& limits);
  void send_bet_request(const int64_t pot, const  ::API::BetLimits& limits);
  int64_t recv_bet_request();
  void competitor_status(const  ::API::Competitor& competitor);
  void send_competitor_status(const  ::API::Competitor& competitor);
  void recv_competitor_status();
  void bet(const  ::API::Competitor& competitor, const  ::API::Bet& bet);
  void send_bet(const  ::API::Competitor& competitor, const  ::API::Bet& bet);
  void recv_bet();
  void hole_card(const  ::API::Card& card);
  void send_hole_card(const  ::API::Card& card);
  void recv_hole_card();
  void community_card(const  ::API::Card& card);
  void send_community_card(const  ::API::Card& card);
  void recv_community_card();
  void showdown(const  ::API::Competitor& competitor, const std::vector< ::API::Card> & cards, const  ::API::HandDescriptor& hand);
  void send_showdown(const  ::API::Competitor& competitor, const std::vector< ::API::Card> & cards, const  ::API::HandDescriptor& hand);
  void recv_showdown();
  void winner(const  ::API::Competitor& competitor, const int64_t amount);
  void send_winner(const  ::API::Competitor& competitor, const int64_t amount);
  void recv_winner();
  void shutdown();
  void send_shutdown();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class PlayerStrategyProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<PlayerStrategyIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (PlayerStrategyProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_name(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_bet_request(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_competitor_status(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_bet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hole_card(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_community_card(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_showdown(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_winner(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_shutdown(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  PlayerStrategyProcessor(boost::shared_ptr<PlayerStrategyIf> iface) :
    iface_(iface) {
    processMap_["name"] = &PlayerStrategyProcessor::process_name;
    processMap_["bet_request"] = &PlayerStrategyProcessor::process_bet_request;
    processMap_["competitor_status"] = &PlayerStrategyProcessor::process_competitor_status;
    processMap_["bet"] = &PlayerStrategyProcessor::process_bet;
    processMap_["hole_card"] = &PlayerStrategyProcessor::process_hole_card;
    processMap_["community_card"] = &PlayerStrategyProcessor::process_community_card;
    processMap_["showdown"] = &PlayerStrategyProcessor::process_showdown;
    processMap_["winner"] = &PlayerStrategyProcessor::process_winner;
    processMap_["shutdown"] = &PlayerStrategyProcessor::process_shutdown;
  }

  virtual ~PlayerStrategyProcessor() {}
};

class PlayerStrategyProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  PlayerStrategyProcessorFactory(const ::boost::shared_ptr< PlayerStrategyIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< PlayerStrategyIfFactory > handlerFactory_;
};

class PlayerStrategyMultiface : virtual public PlayerStrategyIf {
 public:
  PlayerStrategyMultiface(std::vector<boost::shared_ptr<PlayerStrategyIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~PlayerStrategyMultiface() {}
 protected:
  std::vector<boost::shared_ptr<PlayerStrategyIf> > ifaces_;
  PlayerStrategyMultiface() {}
  void add(boost::shared_ptr<PlayerStrategyIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void name(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->name(_return);
    }
    ifaces_[i]->name(_return);
    return;
  }

  int64_t bet_request(const int64_t pot, const  ::API::BetLimits& limits) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->bet_request(pot, limits);
    }
    return ifaces_[i]->bet_request(pot, limits);
  }

  void competitor_status(const  ::API::Competitor& competitor) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->competitor_status(competitor);
    }
    ifaces_[i]->competitor_status(competitor);
  }

  void bet(const  ::API::Competitor& competitor, const  ::API::Bet& bet) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->bet(competitor, bet);
    }
    ifaces_[i]->bet(competitor, bet);
  }

  void hole_card(const  ::API::Card& card) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hole_card(card);
    }
    ifaces_[i]->hole_card(card);
  }

  void community_card(const  ::API::Card& card) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->community_card(card);
    }
    ifaces_[i]->community_card(card);
  }

  void showdown(const  ::API::Competitor& competitor, const std::vector< ::API::Card> & cards, const  ::API::HandDescriptor& hand) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->showdown(competitor, cards, hand);
    }
    ifaces_[i]->showdown(competitor, cards, hand);
  }

  void winner(const  ::API::Competitor& competitor, const int64_t amount) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->winner(competitor, amount);
    }
    ifaces_[i]->winner(competitor, amount);
  }

  void shutdown() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->shutdown();
    }
    ifaces_[i]->shutdown();
  }

};

} // namespace

#endif
